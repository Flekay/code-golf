let N = 1; // = 31
drain 5 { N += 6; }

let buf[36] @1; // = [ [aDigit, bDigit, display?, temp, temp, temp] * 6 ]
buf[0] = 1;
buf[1] = -1;
buf[2] = 1;
// a = 1; b = -1;
// this is so that it prints 0 on the first loop

drain N {
  // do the fibonacci shuffle
  // temp = a;
  // a = a + b;
  // b = temp;
  // or thereabouts:
  bf @1 {
    >>[
      <<{
        // map the current element cells to variables
        let aDigit @0;
        let bDigit @1;
        let shouldDisplay @2;
        assert aDigit unknown;
        assert bDigit unknown;
        assert shouldDisplay equals 1;
        // same for the next element
        let nextA @6;
        let nextB @7;
        let nextDisplay @8;
        assert nextA unknown;
        assert nextB unknown;
        assert nextDisplay unknown;

        {
          let temp;
          drain aDigit into temp bDigit;
          
          let tens = 10; // basically a mod 10 check value
          drain bDigit into aDigit {
            tens -= 1;
            // if not causes like 2 allocations FYI
            if not tens {
              aDigit -= 10;
              // carry
              nextB += 1;
              // make sure the print logic knows this digit has been reached
              nextDisplay = 1;
            }
          }
          drain temp into bDigit;
        }
        
      }>>
    >>>>>>
    ]<<<<<<

    // now print a:  
    // start at the most significant digit (last in the array)
    // check the "display?" byte to see if this digit has been reached yet
    [
      <<{
        let aDigit @0;
        let bDigit @1;
        let shouldDisplay @2;
        assert aDigit unknown;
        assert bDigit unknown;
        assert shouldDisplay equals 1;

        {
          let c = aDigit;
          drain 8 { c += 6; }
          output c;
        }
      }>> <<<<<<
    ]
    // print newline
    ++++++++++.[-]
    // return to the start
    >>>>
  }
}